#' S4 class definition for PRH
#'
#' @include zzz.R
#' @slot tagid A string with the tag ID e.g. "mn180607-44".
#' @slot tagnum A string with the tag number e.g. "44"
#' @slot freq A double with the sampling frequency after decimation in Hz
#'   (typically 10 Hz).
#' @slot tagon,tagoff A POSIXct with the date and time of tag attach and detach
#'   in local time.
#' @slot slips A POSIXct vector with the timestamps of each tag slip.
#' @slot W A list of 3x3 numeric matrices to rotate tag frame into whale frame.
#'   One matrix for each tag orientation (changes on slips).
#' @slot At,Mt,Gt Numeric matrices with accelerometer, magnetometer, and
#'   gyroscope records  calibrated in units of g, microteslas, and radians per
#'   second, respectively in the tag's frame.
#' @slot Aw,Mw,Gw As At, Mt, and Gt, but rotated into the whale's frame.
#' @slot data A tibble with the following columns: \itemize{ \item t A POSIXct
#'   with the date and time of each record. \item p A numeric with the depth
#'   records. \item pitch,roll,head Numerics with the pitch, roll, and heading.
#'   \item speedJJ,speedFN Numerics with speed estimates derived from jiggle and
#'   flow noise, respectively. \item camon A logical, true if the camera is on.}
#' @slot rawdata A tibble with the (decimated) raw data. Removed at the end of
#'   the PRH creation process.
.PRH <- setClass("PRH",
  slots = c(tagid = "character",
            tagnum = "character",
            freq = "numeric",
            tagon = "POSIXct",
            tagoff = "POSIXct",
            slips = "POSIXct",
            At = "matrix",
            Mt = "matrix",
            Gt = "matrix",
            Aw = "matrix",
            Mw = "matrix",
            Gw = "matrix",
            W = "list",
            data = "data.frame",
            rawdata = "data.frame"),
  prototype = list(tagon = num_to_POSIX(0),
                   tagoff = num_to_POSIX(0),
                   slips = num_to_POSIX(0))
)

#' Constructor for PRH class
#'
#' @param tagid A string with the tagid (e.g. "mn180105-22a").
#'
#' @return An object of class PRH with the tagid and tagnum slots filled.
PRH <- function(tagid, tagnum) {
  if (!is.character(tagid) ||
      length(tagid) != 1) {
    stop("tagid must be a length one string.")
  }
  if (!is.character(tagnum) ||
      length(tagnum) != 1) {
    stop("tagnum must be a length one string.")
  }
  if (all(is.na(stringr::str_match(tagid, tagnum)))) {
    warning(stringr::str_glue("WARNING: tagnum \"{tagnum}\" not found in tagid \"{tagid}\"."))
  }

  .PRH(tagid = tagid,
       tagnum = tagnum)
}

#' Initiate a PRH
#'
#' \code{init_prh} tries to load raw tag data.
#'
#' Initiating the PRH process finds the raw data on the CATS drive, imports it,
#' and tidies up the names. The next step is decimating the data to a manageable
#' frequency.
#'
#' @param prh A PRH object.
#' @return A PRH object with the rawdata slot filled
#' @examples
#' \dontrun{
#' prh0 <- PRH("mn180607-44", "44")
#' prh_rawdata <- init_prh(prh0)
#' }
#' @seealso \link{\code{import_cats}}, \link{\code{decimate}}
init_prh <- function(prh) {
  if (!("PRH" %in% class(prh)))
    stop("prh must be a PRH object.")

  tryCatch({
    prh@rawdata <- import_cats(prh@tagid)
    prh
  }, error = function(e) {
    stop(stringr::str_glue("Error initiating tagid {prh@tagid}:\n{e$call}\n{e$message}"))
  })
}

#' Decimate raw data
#'
#' \code{decimate_prh} returns a subset of the raw data at a lower sampling
#' frequency.
#'
#' Decimation chooses every nth record, so the new sampling frequency must be a
#' factor of the original. E.g. 400 Hz can be decimated to 10 Hz but not to 12
#' Hz.
#'
#' @param prh A PRH object.
#' @param new_freq The new sampling frequency. Must be a factor of the old
#'   sampling frequency.
#' @return A PRH with the freq slot filled and rawdata decimated to the new
#'   frequency.
#' @seealso \link{\code{import_cats}}
decimate_prh <- function(prh, new_freq) {
  if (!("PRH" %in% class(prh)))
    stop("prh must be a PRH object.")
  if (nrow(prh@rawdata) < 2)
    stop("PRH raw data must have at least two records.")
  if (!("datetimeUTC" %in% colnames(prh@rawdata)))
    stop("Column datetimeUTC not found in raw data.")
  if (class(new_freq) != "numeric" ||
      length(new_freq) != 1)
    stop("new_freq must be a length one numeric vector.")

  rawdata <- prh@rawdata

  # Test for timestamp issues
  if (is.unsorted(rawdata$datetimeUTC))
    stop("Raw data timestamps out of order, fix before continuing.")
  if (any(as.numeric(diff(rawdata$datetimeUTC)) > 120))
    stop("Raw data has gap(s) greater than two minutes, fix before continuing.")

  # Infer original sampling frequency over a small window
  infer_period <- 1:min(nrow(rawdata), 100)
  old_period <- median(diff(rawdata$datetimeUTC[infer_period]))
  old_freq <- round(1 / as.numeric(old_period, units = "secs"))
  message(stringr::str_glue("Old frequency inferred to be {old_freq} Hz."))

  if (old_freq %% new_freq != 0)
    stop("New frequency is not a factor of old frequency.")

  prh@freq <- new_freq
  prh@rawdata <- dplyr::slice(rawdata, seq(1, nrow(rawdata), by = old_freq / new_freq))
  prh
}

#' Trim data to tag-on period
#'
#' \code{trim_data} removes data from before tag on time and after tag off time.
#' Optionally displays a GUI for interactive tag on/off time selection.
#'
#' @param prh A PRH object. Should already be decimated (see
#'   \link{\code{decimate_prh}})
#' @param use_gui A logical indicating whether to use the interactive plot for
#'   tag on/off time selection.
#' @param tagon,tagoff A POSIXct with the tag on/off time. Ignored if
#'   \code{use_gui} is TRUE (default).
#' @return A PRH with the tagon and tagoff slots filled and the rawdata slot
#'   truncated to tagon:tagoff.
trim_data <- function(prh, use_gui = TRUE, tagon = NA, tagoff = NA) {
  if (!("PRH" %in% class(prh)))
    stop("prh must be a PRH object")
  if (nrow(prh@rawdata) == 0)
    stop("prh rawdata is empty.")
  if (!use_gui) {
    if (!("POSIXct" %in% class(tagon)) ||
        length(tagon) > 1)
      stop("tagon must be a POSIXct of length 1.")
    if (!("POSIXct" %in% class(tagoff)) ||
        length(tagoff) > 1)
      stop("tagoff must be a POSIXct of length 1.")
    if (!("datetimeUTC" %in% colnames(prh@rawdata)))
      stop("Column datetimeUTC not found in prh@rawdata.")
    prh@tagon <- tagon;
    prh@tagoff <- tagoff;
    prh@rawdata <- prh@rawdata %>%
      dplyr::filter(dplyr::between(datetimeUTC, tagon, tagoff))
    prh
  } else {
    result <- tagonoff(prh@rawdata)
    prh@tagon <- result$tagon
    prh@tagoff <- result$tagoff
    prh@rawdata <- result$rawdata
    prh
  }
}

#' Apply bench calibrations
#'
#' \code{bench_cal} applies bench calibrations to raw data. Calibrates inertial
#' sensors and fills in the At, Gt, and Mt slots. At, Mt, and Gt are in units of
#' g, microteslas, and radians per second, respectively, in the tag's frame.
#' Then calibrates the pressure sensor and fills in the p field in the data
#' slot. Also fills in the t and camon fields in the data slot.
#'
#' @param prh A PRH object. Should already be decimated (see
#'   \link{\code{decimate_prh}}) and trimmed (see \link{\code{trim_prh}})
#' @return A PRH object with updated rawA, rawG, rawM, At, Gt, and Mt slots.
bench_cal <- function(prh) {
  if (nrow(prh@rawdata) == 0)
    stop("PRH data is empty - have you initiated it?")
  if (length(prh@freq) == 0)
    stop("PRH frequency not set - have you decimated it?")
  if (prh@tagon == num_to_POSIX(0) ||
      prh@tagoff == num_to_POSIX(0))
    stop("PRH tagon/tagoff not set - have you trimmed it?")

  cal <- load_cal(prh@tagnum)

  # Fill in column t in prh@data from prh@rawdata
  prh@data <- prh@rawdata %>%
    dplyr::select(t = datetimeUTC)

  # Apply bench calibrations
  apply_cal <- function(sensor) {
    if (!(sensor %in% c("a", "g", "mon", "moff")))
      stop("sensor must be one of c(\"a\", \"g\", \"mon\", \"moff\")")

    # Get calibration slopes and constants
    cal_const <- cal[[paste0(sensor, "const")]]
    cal_slope <- cal[[paste0(sensor, "cal")]]
    if (is.null(cal_const) || is.null(cal_slope)) browser()

    # Get raw intertial sensor values
    sensor_name <- switch(sensor,
                          a = "acc",
                          g = "gyr",
                          mon = "mag",
                          moff = "mag")
    vals <- dplyr::select(prh@rawdata,
                          dplyr::starts_with(sensor_name)) %>%
      as.matrix

    # Apply calibration
    (vals %*% cal_slope) + matrix(rep(cal_const, each = nrow(vals)),
                                  nrow = nrow(vals))
  }
  cal_mats <- purrr::map(c("a", "g", "mon", "moff"), apply_cal)
  prh@At <- cal_mats[[1]]
  prh@Gt <- cal_mats[[2]]
  # Use different magnetometer calibrations for when the camera is on and off
  prh@data$camon <- prh@rawdata$ccStatus != "---"
  mon <- cal_mats[[3]]
  mon[!prh@data$camon,] <- 0
  moff <- cal_mats[[4]]
  moff[prh@data$camon,] <- 0
  prh@Mt <- mon + moff

  # Calibrate pressure (note: constant is subtracted, not added)
  prh@data$p <- prh@rawdata$depthM * cal$pcal - cal$pconst

  prh
}
